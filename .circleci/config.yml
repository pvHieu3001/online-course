version: 2.1

executors:
  node-executor:
    docker:
      - image: cimg/node:20.19.0
    working_directory: ~/project
  java-executor:
    docker:
      - image: cimg/openjdk:17.0
    working_directory: ~/project
  docker-executor:
    docker:
      - image: docker:24.0.2
    working_directory: ~/project

jobs:
  build-fe:
    executor: node-executor
    steps:
      - checkout
      - restore_cache:
          keys:
            - v1-dependencies-fe-{{ checksum "fe/package.json" }}
            - v1-dependencies-fe-
      - run:
          name: Clean and install dependencies
          command: |
            cd fe
            rm -rf node_modules package-lock.json
            npm cache clean --force
            npm install --legacy-peer-deps
      - save_cache:
          paths:
            - fe/node_modules
          key: v1-dependencies-fe-{{ checksum "fe/package.json" }}
      - run:
          name: Verify Vite installation
          command: cd fe && npx vite --version
      - run:
          name: Build FE
          command: cd fe && npx vite build
      - persist_to_workspace:
          root: fe
          paths:
            - dist
  test-fe:
    executor: node-executor
    steps:
      - checkout
      - restore_cache:
          keys:
            - v1-dependencies-fe-{{ checksum "fe/package.json" }}
            - v1-dependencies-fe-
      - run:
          name: Install dependencies (if cache miss)
          command: |
            cd fe
            if [ ! -d "node_modules" ]; then
              rm -rf node_modules package-lock.json
              npm cache clean --force
              npm install --legacy-peer-deps
            fi
      - run:
          name: Test FE
          command: cd fe && npm test || true
  build-be:
    executor: java-executor
    steps:
      - checkout
      - run:
          name: Grant execute permission for mvnw
          command: cd be && chmod +x mvnw
      - run:
          name: Build BE
          command: cd be && ./mvnw clean install -DskipTests
      - persist_to_workspace:
          root: be
          paths:
            - target
            - dockerfile
            - docker-compose.yml
            - pom.xml
            - src
  test-be:
    executor: java-executor
    steps:
      - checkout
      - run:
          name: Grant execute permission for mvnw
          command: cd be && chmod +x mvnw
      - run:
          name: Test BE
          command: cd be && ./mvnw test
  deploy-fe:
    executor: node-executor
    steps:
      - checkout
      - attach_workspace:
          at: fe
      - add_ssh_keys:
          fingerprints:
            - "SHA256:2ddCb9OOC47UzX27NS3G1bHd5FeEFd7MD4++MtqCBQY"
      - run:
          name: Deploy Frontend to Server
          command: |
            # Create deployment script
            cat > deploy-fe.sh \<< 'EOF'
            #!/bin/bash
            set -e
            set -x

            # Server configuration from environment variables
            SERVER_HOST="${SERVER_HOST:-your-server.com}"
            SERVER_USER="${SERVER_USER:-deploy}"
            FRONTEND_PATH="${FRONTEND_PATH:-/var/www/frontend}"
            BACKUP_PATH="${BACKUP_PATH:-/var/www/backups}"

            echo "ðŸš€ Starting frontend deployment to ${SERVER_HOST}..."

            # Create backup directory if it doesn't exist
            ssh -o StrictHostKeyChecking=no ${SERVER_USER}@${SERVER_HOST} "mkdir -p ${BACKUP_PATH}"

            # Create timestamp for backup
            TIMESTAMP=$(date +%Y%m%d_%H%M%S)

            # Backup current frontend if it exists
            if ssh -o StrictHostKeyChecking=no ${SERVER_USER}@${SERVER_HOST} "[ -d ${FRONTEND_PATH} ]"; then
              echo "ðŸ“¦ Creating backup of current frontend..."
              ssh -o StrictHostKeyChecking=no ${SERVER_USER}@${SERVER_HOST} "tar -czf ${BACKUP_PATH}/frontend_backup_${TIMESTAMP}.tar.gz -C ${FRONTEND_PATH} ."
            fi

            # Create frontend directory if it doesn't exist
            ssh -o StrictHostKeyChecking=no ${SERVER_USER}@${SERVER_HOST} "mkdir -p ${FRONTEND_PATH}"

            # Upload new frontend build
            echo "ðŸ“¤ Uploading new frontend build..."
            scp -o StrictHostKeyChecking=no -r fe/dist/* ${SERVER_USER}@${SERVER_HOST}:${FRONTEND_PATH}/

            # Set proper permissions
            ssh -o StrictHostKeyChecking=no ${SERVER_USER}@${SERVER_HOST} "chmod -R 755 ${FRONTEND_PATH}"

            # Restart nginx if it exists
            if ssh -o StrictHostKeyChecking=no ${SERVER_USER}@${SERVER_HOST} "systemctl is-active --quiet nginx"; then
              echo "ðŸ”„ Restarting nginx..."
              ssh -o StrictHostKeyChecking=no ${SERVER_USER}@${SERVER_HOST} "sudo systemctl reload nginx"
            fi

            echo "âœ… Frontend deployment completed successfully!"
            EOF

            chmod +x deploy-fe.sh
            ./deploy-fe.sh
  deploy-be:
    executor: java-executor
    steps:
      - checkout
      - attach_workspace:
          at: be
      - add_ssh_keys:
          fingerprints:
            - "SHA256:2ddCb9OOC47UzX27NS3G1bHd5FeEFd7MD4++MtqCBQY"
      - run:
          name: Verify workspace contents
          command: |
            echo "Current directory: $(pwd)"
            echo "Directory contents:"
            ls -la
            echo "Target directory contents:"
            ls -la target/ || echo "Target directory not found"
      - run:
          name: Deploy Backend to VPS
          command: |
            # Create deployment script
            cat > deploy-be.sh \<< 'EOF'
            #!/bin/bash
            set -e
            set -x

            # Server configuration from environment variables
            SERVER_HOST="${SERVER_HOST:-your-server.com}"
            SERVER_USER="${SERVER_USER:-deploy}"
            BACKEND_PATH="${BACKEND_PATH:-/home/deploy/online-course/be}"
            BACKUP_PATH="${BACKUP_PATH:-/var/www/backups}"
            DOCKER_IMAGE_NAME="${DOCKER_IMAGE_NAME:-online-course-backend}"
            DOCKER_CONTAINER_NAME="${DOCKER_CONTAINER_NAME:-online-course-backend}"

            echo "ðŸš€ Starting backend deployment to ${SERVER_HOST}..."

            # Create backup directory if it doesn't exist
            ssh -o StrictHostKeyChecking=no ${SERVER_USER}@${SERVER_HOST} "mkdir -p ${BACKUP_PATH}"

            # Create timestamp for backup
            TIMESTAMP=$(date +%Y%m%d_%H%M%S)

            # Find the JAR file (fix path)
            JAR_FILE=$(find be/target -name "*.jar" -not -name "*sources.jar" -not -name "*javadoc.jar" | head -1)

            if [ -z "$JAR_FILE" ]; then
              echo "âŒ No JAR file found in be/target directory"
              echo "be/target directory contents:"
              ls -la be/target/ || echo "be/target directory not found"
              exit 1
            fi

            echo "ðŸ“¦ Found JAR file: $JAR_FILE"

            # Create backend directory if it doesn't exist
            ssh -o StrictHostKeyChecking=no ${SERVER_USER}@${SERVER_HOST} "mkdir -p ${BACKEND_PATH}"

            # Backup current Docker image if it exists
            #if ssh -o StrictHostKeyChecking=no ${SERVER_USER}@${SERVER_HOST} "docker images | grep -q ${DOCKER_IMAGE_NAME}"; then
            #  echo "ðŸ“¦ Creating backup of current Docker image..."
            #  ssh -o StrictHostKeyChecking=no ${SERVER_USER}@${SERVER_HOST} "docker save ${DOCKER_IMAGE_NAME}:latest | gzip > ${BACKUP_PATH}/backend_docker_backup_${TIMESTAMP}.tar.gz"
            #fi

            # Stop and remove current container if it exists
            if ssh -o StrictHostKeyChecking=no ${SERVER_USER}@${SERVER_HOST} "docker ps -a | grep -q ${DOCKER_CONTAINER_NAME}"; then
              echo "ðŸ›‘ Stopping and removing current container..."
              ssh -o StrictHostKeyChecking=no ${SERVER_USER}@${SERVER_HOST} "docker stop ${DOCKER_CONTAINER_NAME} || true"
              # ssh -o StrictHostKeyChecking=no ${SERVER_USER}@${SERVER_HOST} "docker images | grep '<none>' | awk '{print $3}' | xargs -r docker rmi"
            fi

            # Remove old Docker image
            ssh -o StrictHostKeyChecking=no ${SERVER_USER}@${SERVER_HOST} "docker rmi ${DOCKER_IMAGE_NAME}:latest || true"
            ssh -o StrictHostKeyChecking=no ${SERVER_USER}@${SERVER_HOST} "docker rmi ${DOCKER_IMAGE_NAME}:latest || true"

            # Upload entire backend directory with existing Docker files
            echo "ðŸ“¤ Uploading backend files..."
            scp -o StrictHostKeyChecking=no -r be/target/online-course-0.0.1-SNAPSHOT.jar ${SERVER_USER}@${SERVER_HOST}:${BACKEND_PATH}/target/
            scp -o StrictHostKeyChecking=no -r be/docker-compose.yml ${SERVER_USER}@${SERVER_HOST}:${BACKEND_PATH}/
            scp -o StrictHostKeyChecking=no -r be/dockerfile ${SERVER_USER}@${SERVER_HOST}:${BACKEND_PATH}/
            scp -o StrictHostKeyChecking=no -r be/src/main/resources/application-docker.properties ${SERVER_USER}@${SERVER_HOST}:${BACKEND_PATH}/

            # Create uploads directory on server
            ssh -o StrictHostKeyChecking=no ${SERVER_USER}@${SERVER_HOST} "mkdir -p /var/www/uploads"

            # Run new container with docker-compose
            echo "ðŸš€ Starting new container with docker-compose..."
            ssh -o StrictHostKeyChecking=no ${SERVER_USER}@${SERVER_HOST} "cd ${BACKEND_PATH} && SPRING_PROFILES_ACTIVE=docker docker compose up -d --build"

            echo "âœ… Backend deployment completed successfully!"
            EOF

            chmod +x deploy-be.sh
            ./deploy-be.sh

workflows:
  version: 2
  build-and-test:
    jobs:
      - build-fe
      - test-fe:
          requires:
            - build-fe
      - build-be
      - test-be:
          requires:
            - build-be
      - deploy-fe:
          requires:
            - build-fe
          filters:
            branches:
              only: master
      - deploy-be:
          requires:
            - build-be
          filters:
            branches:
              only: master
